---

title: 操作系统

layout: post

---

* [概述](#intr)
* [进程](#proc)
* [并发](#conc)
* [内存](#memo)
* [处理器调度](#sche)
* [i／o管理和磁盘调度](#io)

<h2 id="intr">概述</h2>

1，计算机由处理器、主存、输入输出模块和系统总线构成。

2，处理器寄存器包括用户可见寄存器（数据／地址／索引）和控制状态寄存器（程序计数器／指令寄存器）。

3，基本指令周期包含取指阶段和执行阶段，程序计数器中保存由下一条指令等地址，取到的指令被保存到指令寄存器中。

4，存储器的层次结构根据局部性原理设计，按照存取速度排列：寄存器、高速缓存、主存、磁盘... 高速缓存与cpu采用字传送，与主存采用块传送。

5，I/O操作分为可编程I/O（cpu不停地监视）、中断驱动I/O（发送I/O命令后继续其他工作，等待中断请求）和直接存储器访问（dma不通过cpu而直接与存储器交互），

<h2 id="proc">进程</h2>

1，进程由程序代码和相关数据以及进程控制块组成，进程控制块包含进程标示、处理器状态信息和处理器控制信息。

2，进程通常具有用户模式和内核模式两种执行模式。

3，进程通常包含新建、就绪、运行、阻塞和退出五个状态，为了节约主存空间提高运行效率，增加了就绪挂起和阻塞挂起状态将进程保存到磁盘中。

4，多线程环境将进程定义为资源分配和保护的单位，而处理器负责调度／执行线程，进程中的所有线程共享该进程的状态和资源，同时每个线程都有自己的线程控制块和自己的栈。线程有运行、就绪和阻塞三个状态。

5，线程分为用户级线程和内核级线程，用户级线程不需要模式切换因此效率高，但是一个进程中一次只有一个用户级线程可以执行，并且这个线程阻塞会导致整个进程阻塞；内核级线程则可以并行执行并且不会导致整个进程阻塞，但线程切换时需要进行模式切换。

6，用户级线程可以在任意处理器上运行，通过对称多处理技术，内核级线程也可以在任意处理器上运行。

7，微内核是一种内核中只包含最基本功能的操作系统设计方案。

8，每个线程拥有自己的程序计数器、寄存器、堆栈和状态。同一进程下的线程共享进程的地址空间和资源。

9，多道程序设计指的是单cpu在不同程序间切换。

<h2 id="conc">并发</h2>

1，临界区是一段访问共享资源的代码；死锁是两个或两个以上进程的每个进程都在等待其他进程做完某件事情而无法执行；饥饿是一个可运行进程被调度器无限期的忽视（如三个进程）。

2，进程间有三种交互方式：互不知道而产生竞争；间接知道而通过共享合作；直接知道而通过通信合作。

3，互斥的实现：中断禁用；机器指令（testset／exchange）；信号量；管程；消息传递。

4，信号量包含一个计数器和一个队列，有semWait和semSignal两种操作。采用fifo队列的信号量称为强信号量，不会产生饥饿。

```c
// 信号量
struct semaphore {
  int count; // usually init to 1
  queueType queue;
}

void semWait(semaphore s) {
  s.count--;
  if(s.count < 0) {
    // place this process to s.queue;
    // block this process;
  }
}

void semSignal(semaphore s) {
  s.count++;
  if(s.count <= 0) {
    // remove a process from s.queue;
    // place this process to ready list;
  }
}

// 信号量实现互斥
const int n; // count of processes
semaphore s = 1; // init to 1

void P(int i) {
  while(true) {
    semWait(s);
    // into critical section
    semSignal(s);
    // remainder...
  }
}

void main() {
  parbegin(P(1), P(2)... P(n));
}

//信号量实现生产者消费者问题-无限缓冲区
semaphore n = 0;
semaphore s = 1;

void producer() {
  while(true) {
    produce();
    semSignal(n);
    semWait(s);
    append();
    semSignal(s);
  }
}

void consumer() {
  while(true) {
    semWait(n);
    semWait(s);
    take();
    semSignal(s);
    consume();
  }
}

void main() {
  parbegin(producer,consumer);
}
```

5，死锁的三个必要条件是：互斥、占有且等待、非抢占。若还满足循环等待则会产生死锁。可通过死锁预防、死锁避免和死锁检测处理死锁。

6，死锁预防通过防止四个条件的任何一个的发生，从而避免死锁，但是效率低下，可能需要抢占／一次性请求所有资源／对资源排序等。

7，死锁避免允许前三个必要条件的发生，通过明智的选择确保永远不会到达死锁点。分为进程启动拒绝和资源分配拒绝（银行家算法）两种算法。

8，银行家算法通过合理的资源分配策略达到死锁避免：当某个进程请求一组资源时，假设同意该请求后结果仍处于安全状态，则同意该请求，否则阻塞该进程直到同意该请求后结果仍是安全的。

9，死锁检测算法不限制资源访问和进程行为，通过周期性的检测是否产生循环等待来防止死锁。

10，信号量解决哲学家就餐问题

```c
semaphore fork[5] = 1;
semaphore room = 4;
int i;
void philosopher(int i) {
  while(true) {
    think();
    wait(room);
    wait(fork[i]);
    wait(fork[(i+1) mod 5]);
    eat();
    signal(fork[i]);
    signal(fork[(i+1) mod 5]);
    signal(room);
  }
}
void main() {
  parbegin(philosopher(0)...(4));
}
```

11，并行指的是多个事件在同一时刻发生；并发指的是多个事件在同一时间间隔发生。

<h2 id="memo">内存</h2>

1，内存管理需要满足：重定位、保护、共享、逻辑组织和物理组织。

2，内存管理技术：（固定分区和动态分区就像套餐和自助餐）

* 固定分区：大小相等／大小不等，产生内部碎片

* 动态分区：产生外部碎片（因此需要压缩），有最佳适配、首次适配和临近适配三种放置策略，首次适配通常是最好最快的。

* 伙伴系统是综合了固定分区和动态分区的改进，如果请求的大小大于可用空间的一半，则分配整个空间，否则将可用空间不断分成两半直到满足条件分配给这个请求。

* 简单分页：进程分成页，内存分成帧，将进程的所有页放入主存中不一定连续的帧中，无外部碎片

* 简单分段：进程分成段，放入内存中不一定连续的动态分区，无内部碎片

* 虚拟内存分页：无需将进程所有页放入主存的简单分页

* 虚拟内存分段：无需将进程所有段放入主存的简单分段

3，分页时n+m位地址的转换：提取逻辑地址左边的n位为页号，以该页号为索引查找进程页表找到帧号k，该帧的起始物理地址为k*2^m，加上偏移量则为物理地址。
分段则需要将偏移量与段长度进行比较，若偏移量大于该长度，则该地址无效。

4，**系统抖动**指处理器将大部分时间用于交换块，而非执行指令。**局部性原理**证明了虚拟内存的可行性。

5，**读取策略**决定何时将一页读入内存，分为**请求式分页**（需要时才读入）和**预约式分页**（一次读取多个连续页）。同理，**清除策略**也分为请求式清除和预约式清除。

6，**替换策略**算法有最佳/opt，最近最少使用/lru，先进先出/fifo和时钟/clock。

opt选择替换下次访问距当前时间最长的页，是理想状态下的最佳算法。

lru替换主存中上次使用距当前最远的页。

fifo按顺序循环移动页。

clock。

7，分页取一次数据访问2次内存，地址是一维的；分段访问3次内存，地址是二维的。

8，段页式存储为每个进程维护一张段表，每个段维护一张页表。

<h2 id="sche">处理器调度</h2>

1，长程调度决定那一个程序可以进入到系统中被处理（新建－就绪）；中程调度决定加入到部分或全部在主存中的进程集合（挂起－就绪）；短程调度决定那一个可用进程被处理（就绪－运行）。

2，**调度策略**有先来先服务fcfs、轮转、最短进程优先spn、最短剩余时间优先srt、最高响应比优先hrrn和反馈。

3，归一化周转时间＝周转时间／服务时间。用于表明一个进程的相对延迟，

<h2 id="io">i/o管理和磁盘调度</h2>

1，i/o分为可编程i/o、可中断i/o和直接存储器访问dma。

2，磁盘读写单位是扇区，磁盘空间地址包括扇区号、柱面号和盘面号。
